---
id: 1c42tiomb7vf83bkch5i1b9
title: 'verbs vs relators'
desc: ''
updated: 1729469859527
created: 1728318054728
---

- interlocutor: @chatgpt.4o

## in english, the standard tense is "present". Are there other languages where the standard tense is something else?

Yes, there are languages where the "standard" or most frequently used tense differs from English. While English tends to default to the **present tense** for general statements, habitual actions, or descriptions, other languages might use different tenses or focus less on tense altogether.

Here are some examples of languages where a different tense or concept plays a more central role:

### 1. **Narrative Past as Standard Tense:**
   - **French**: In spoken French, the **passé composé** (a form of the perfect past tense) is often used as the default for talking about past events, including events that in other languages would be described with a simple past tense. It takes on the role of what we would think of as the standard "past tense" in narrative.
   - **German**: Similarly, in spoken German, the **Perfekt** tense (the equivalent of the present perfect in English) is often used instead of the simple past (**Präteritum**) to describe completed actions. The **Präteritum** is more common in writing or formal contexts.

### 2. **Aspect Rather than Tense:**
   - **Russian**: Russian, like other Slavic languages, places more emphasis on **aspect** (perfective vs. imperfective) rather than tense. While there are past, present, and future tenses, the choice of aspect (whether the action is completed or ongoing) is often more central to understanding the meaning of a verb form. The "default" form often depends on whether the action is seen as habitual or completed rather than just the present time.
  
### 3. **Absence of Standard Tense:**
   - **Chinese (Mandarin)**: Mandarin Chinese lacks verb conjugation for tense. Instead, **aspect markers** and context indicate the time of an action. The "default" verb form is often a bare verb (uninflected), and time is implied through context or time adverbs. For example, "I eat" could mean "I am eating," "I eat regularly," or "I will eat," depending on the context.

### 4. **Focus on Future or Past:**
   - **Haitian Creole**: In Haitian Creole, the **past tense** marker "te" and the **future tense** marker "va" are frequently used, but for general statements, the present tense can imply both present and habitual action without any specific marker. The use of these markers can make it seem as if the focus is more on specifying non-present times rather than having a default present tense.

### 5. **Non-Temporal Focus (Tense-Agnostic Languages):**
   - **Indigenous Australian Languages**: Many Indigenous Australian languages focus more on the **evidentiality** (how the speaker knows something) and **aspect** rather than tense. Some languages might not have a distinct "default tense" because they are more concerned with whether an action is ongoing, completed, or whether the speaker witnessed it personally.

### 6. **Default to Past Tense in Narratives:**
   - **Spanish**: In spoken narratives, Spanish often defaults to the **preterite** (simple past) when telling stories or giving recounts. In certain dialects, the **imperfect** tense is also heavily used to describe habitual past actions or ongoing background events, making it feel like a common "default" for discussing the past.

### 7. **Japanese**:
   - In **Japanese**, verbs do not have strict tense in the same way as English. Instead, verbs are marked for **past** and **non-past**, where "non-past" can refer to both present and future actions. The "standard" tense often depends on context, and the non-past form is quite versatile for expressing both current and future actions.

**Summary**: In English, the **present tense** is the standard or default tense used for many general statements. However, other languages might default to a **past tense** (as in French or German for narratives), focus on **aspect** (as in Russian), or even lack tense distinctions entirely (as in Chinese). These differences reflect how cultures and languages structure their understanding of time and action.


## what is aspect?

**Aspect** is a grammatical category that describes the **temporal flow or nature of an action**, focusing on whether the action is completed, ongoing, habitual, repeated, or momentary. While **tense** tells us **when** an action occurs (past, present, future), **aspect** tells us more about **how** the action unfolds over time.

There are two main types of aspect in most languages:

### 1. **Perfective vs. Imperfective Aspect**:
   - **Perfective Aspect**: Describes an action as a **single, completed event** without focusing on its internal structure or progression. It presents an action as a whole, often with a clear beginning and end.
     - Example: *She wrote a letter.* (the action is viewed as complete)
   - **Imperfective Aspect**: Describes an action as **ongoing, habitual, or repeated**. It focuses on the process or continuity of the action, rather than seeing it as a finished event.
     - Example: *She was writing a letter.* (the action is viewed as being in progress)
     - Example: *She writes letters every day.* (habitual action)

### 2. **Common Types of Aspect**:

- **Progressive/Continuous Aspect**: Focuses on an action **in progress** at a particular time.
  - Example: *I am eating.* (currently ongoing)
  
- **Habitual Aspect**: Refers to an action that occurs **regularly or habitually** over time.
  - Example: *I eat breakfast at 7 a.m. every day.* (repeated over time)

- **Perfect Aspect**: Expresses an action that is **completed** or that has relevance to a later time, often with consequences for the present.
  - Example: *I have eaten.* (the action is complete, but it has present relevance, like feeling full now)

### Examples Across Languages:

- **English** uses a combination of **tense and aspect markers** to convey both time and nature of actions:
  - **Present Continuous (Progressive Aspect)**: *I am reading* (action is ongoing now)
  - **Present Perfect (Perfect Aspect)**: *I have read the book* (completed action with present relevance)

- **Russian** and other Slavic languages** make a strong distinction between **perfective** and **imperfective** forms of verbs:
  - Perfective verbs are used when focusing on the **completion** of an action: *Я написал письмо* (I wrote the letter — completed).
  - Imperfective verbs focus on the **process or repetition**: *Я писал письмо* (I was writing the letter — ongoing or habitual).

- **Mandarin Chinese** uses **aspect markers** rather than verb conjugation to indicate the nature of an action:
  - The particle *了 (le)* indicates a **completed action**: *我吃了饭* (I have eaten).
  - The particle *着 (zhe)* indicates an **ongoing state**: *他看着书* (He is reading a book — ongoing action).

### Summary:
- **Aspect** is about the **nature of an action in time**, focusing on its flow, completion, or repetition.
- It works alongside **tense**, which indicates **when** an action happens.
- Different aspects help describe whether an action is finished, ongoing, or habitual, providing a richer picture of the action in relation to time.

## what is the term for past/present/future, given that tense varies from language to language. 

The term you're looking for is **"temporal reference"** or simply **"time reference"**. This term is used to describe the **time frame** in which an action, event, or state occurs, without implying a specific grammatical mechanism like "tense." Temporal reference helps capture the broader concept of **past, present, and future** as they apply across different languages and systems of expressing time.

- **Temporal Reference**: Refers to the actual time context in which an event takes place—whether it is in the **past**, **present**, or **future**. Unlike tense, which is a grammatical feature, temporal reference is more about the conceptual timeline of the event.

For example:
- In English, we use **tense** (e.g., past, present, future) to indicate temporal reference.
- In other languages like **Mandarin Chinese**, temporal reference is often conveyed through context or temporal markers rather than changes in verb tense.

Using "temporal reference" makes it possible to discuss the timing of actions without assuming a specific grammatical form, accommodating the many different ways languages handle the expression of time.

## what other features besides temporal reference and aspect are captured in tense

Besides **temporal reference** and **aspect**, there are other features that are often expressed as part of a language's tense system or that interact with tense. These include:

### 1. **Mood**:
   - **Mood** conveys the speaker’s **attitude** toward the action or state described by the verb. This can include certainty, obligation, desire, or hypothetical situations.
   - Common moods include:
     - **Indicative**: Used to state facts or ask questions (e.g., *She is running*).
     - **Subjunctive**: Used for wishes, doubts, or hypothetical situations (e.g., *If I were taller...*).
     - **Imperative**: Used to give commands or make requests (e.g., *Run!*, *Please close the door*).

### 2. **Voice**:
   - **Voice** relates to the relationship between the **action** and the **subject** or **object** in a sentence.
   - The main types of voice are:
     - **Active Voice**: The subject performs the action (e.g., *She writes a letter*).
     - **Passive Voice**: The subject receives the action (e.g., *A letter is written by her*).

### 3. **Polarity**:
   - **Polarity** indicates whether an action or state is **affirmed** (positive) or **negated** (negative).
   - Positive polarity: *She is running*.
   - Negative polarity: *She is not running*.

### 4. **Evidentiality**:
   - **Evidentiality** marks the **source of information** or **evidence** for a statement. It can indicate whether something is known through direct evidence, hearsay, inference, etc.
   - In English, evidentiality is often expressed through phrases (e.g., *I heard that she is running*), but some languages like **Quechua** or **Turkish** have specific evidential markers in the verb system.

### 5. **Person and Number**:
   - **Person** indicates **who** is involved in the action (e.g., first person - *I run*, second person - *you run*, third person - *he/she/it runs*).
   - **Number** expresses **whether** the action involves one person or more (singular vs. plural).
   - Many languages, like Spanish, also inflect verbs to match the person and number of the subject.

### 6. **Telicity**:
   - **Telicity** indicates whether an action has a **defined endpoint** or **goal**.
   - A **telic** action is one that naturally ends when its goal is achieved (e.g., *She wrote a book* implies completion).
   - An **atelic** action does not have a natural endpoint and can continue indefinitely (e.g., *She ran* does not specify whether she finished running).

### 7. **Iteration or Frequency**:
   - Some verb systems include markers to express how **often** an action occurs.
   - For example, a **frequentative** aspect or marker indicates repeated actions (e.g., in Finnish, adding specific suffixes can indicate habitual or repeated actions).

### 8. **Modality** (closely related to mood):
   - **Modality** is used to express **possibility, necessity, obligation, or ability**.
   - Modal verbs in English (like *can*, *may*, *must*, *should*) help convey these meanings.

### Summary:
Tense systems can incorporate many different features beyond just temporal reference and aspect, such as **mood**, **voice**, **polarity**, **evidentiality**, **person and number**, **telicity**, **iteration/frequency**, and **modality**. These features help provide a richer understanding of not just **when** an action takes place, but also the **nature** of the action, the **speaker's attitude**, and **how** the action relates to the participants.

## could you call them relational categories?

"Relational categories" might not be the most accurate term to describe features like **mood**, **voice**, **polarity**, and **evidentiality**. These features do not necessarily express relationships between entities, which is what the term "relational" typically implies. Instead, they modify the meaning of the verb by adding nuances about **how**, **why**, **who**, or **in what way** the action takes place, rather than defining relationships in a direct sense.

For example:

- **Mood** conveys the speaker's attitude (e.g., factual, hypothetical).
- **Voice** indicates whether the subject is acting or being acted upon.
- **Polarity** expresses whether something is affirmed or negated.
- **Evidentiality** relates to the source or type of evidence behind the statement.

A more suitable term could be **"verbal modality categories"** or **"verbal features"**, as these terms capture the function of modifying the meaning or adding information to a verb in a general way.

"Relational" is better suited for categories that express relationships explicitly, such as grammatical **case** (e.g., nominative, accusative) which shows the syntactic role of nouns in relation to verbs or other nouns.


## OKay, so maybe "relator-based ontologies" might not be the best name for my approach to ontologies where instead of using predicates in the conventional way, predicates become classes, and expressions of those predicates are instances of the predicate classes.

In your case, "relator-based" might not quite capture the essence of the approach. Since your method involves treating **predicates as classes**, with **expressions of those predicates** as instances, it might be better to focus on terminology that reflects this shift from predicates as relations to predicates as **entities**.

Here are some suggestions:

1. **Predicate-Instance Ontologies**: This clearly describes that predicates are treated as **classes**, and their **instances** are specific relationships.

2. **Relational Entity Ontologies**: Highlights the fact that the relationships themselves are treated as **entities** (or classes).

3. **Predicate Reification Ontologies**: Since you are essentially reifying predicates—turning them into first-class objects or classes—this term reflects that approach well.

4. **Meta-Predicate Ontologies**: Suggests that the predicates are elevated to a **meta** level, treated as classes.

5. **Assertion-Centric Ontologies**: Since you're focusing on **assertions** as entities that can be instances, this emphasizes the expressive power of those assertions.

The term should ideally reflect the **shift of predicates from the role of relationships to concrete entities** and the **expressiveness** that comes with making statements about these instances.


## I like "predicate-instance" better than something with "verb" because a verb has connotations of a single word. Remind me the difference between a predicate and a verb phrase?

The difference between a **predicate** and a **verb phrase** is in their roles within sentence structure:

### **Predicate**:
- The **predicate** is a grammatical term referring to the part of a sentence or clause that states **something about the subject**. It usually contains a **verb** and may also include objects, complements, and modifiers.
- In simple terms, the predicate is **everything in the clause except the subject**.
- Example: In the sentence "*The cat is sleeping on the mat*", the predicate is "*is sleeping on the mat*" because it describes what the subject ("the cat") is doing.

### **Verb Phrase**:
- A **verb phrase** is a part of the predicate that contains the **main verb** and any **auxiliary (helping) verbs**. It may also include modifiers or complements.
- A verb phrase can be part of a larger predicate but doesn’t necessarily contain all the elements of the predicate.
- Example: In "*The cat is sleeping on the mat*", the verb phrase is "*is sleeping*" because it includes the auxiliary verb "is" and the main verb "sleeping".

### Summary of Differences:
- **Predicate**: Everything that tells you something about the subject, often including the verb, objects, and other components.
- **Verb Phrase**: The **main verb** and any auxiliary verbs within the predicate, which directly indicate the action or state.

The **predicate** is broader and contains all of the elements that provide information about the subject, while the **verb phrase** focuses specifically on the verb and related components.

## for active vs passive voice, is "the boat flipped" active and "the boat was flipped" passive? It seems a subtle distinction

Yes, there's a subtle but important distinction between **"the boat flipped"** and **"the boat was flipped"** that relates to **voice**:

### 1. **Active Voice: "The boat flipped"**:
- This is **active voice**, even though it might not seem obvious because the **boat** is the subject and the action appears to have happened to it. In this context, the verb "**flipped**" is **intransitive** (meaning it doesn’t take a direct object), and it suggests that the action happened **on its own** or without explicitly stating an external agent. 
- There is no direct implication of someone or something causing the boat to flip. It just flipped.

### 2. **Passive Voice: "The boat was flipped"**:
- This is **passive voice**. The verb **"was flipped"** is a combination of a form of "**to be**" (in this case, "was") and the past participle "**flipped**."
- It implies that the boat was **acted upon by an external agent**, even if that agent isn’t explicitly mentioned. For instance, "*The boat was flipped* (by a wave)." 
- The passive voice emphasizes the action being done to the **subject** rather than focusing on what caused it.

### Summary:
- **"The boat flipped"** is **active** and focuses on the action happening to the boat on its own.
- **"The boat was flipped"** is **passive** and suggests that something **acted upon** the boat.

The distinction lies in whether the subject **performs** the action (active) or **receives** the action from an external source (passive).


## Is there any prior art or research papers around using RDF to represent knowledge/statements in a "predicate-instance" kind of way?

There is some prior art and related research in using **RDF** to represent knowledge/statements in a way that resembles the **"predicate-instance"** approach you're describing, often in the context of **reification**, **named graphs**, or **n-ary relations**. Here are some approaches that are somewhat similar and might be of interest to you:

### 1. **RDF Reification**:
   - **Reification** in RDF is a method of making statements **about statements**. It involves representing a triple (subject-predicate-object) as a **first-class entity** (essentially turning it into a resource), so you can add metadata or make assertions about it. 
   - Example: Reifying a statement like *"Alice knows Bob"* involves creating a new resource that represents this statement, and then you can add properties like *"source"* or *"confidence"* to this resource.
   - This approach aligns somewhat with treating a **predicate-instance** as a **class** where the **statement** is treated as an instance.
   - A significant limitation is that RDF reification is often cumbersome and requires many triples to represent a single statement, which can make the data model harder to work with.

### 2. **N-ary Relations in RDF**:
   - The **n-ary relation** pattern is used to represent relationships involving more than two entities or to provide additional context about a relationship (e.g., time, value, or other qualifiers).
   - Instead of a simple predicate linking two entities, an **intermediate resource** is introduced that acts as the instance of the relationship, and attributes of this instance represent the additional context.
   - This intermediate resource can be treated similarly to an **instance of a predicate**, adding more flexibility to model complex relationships.
   - For example, to represent *"Alice gave Bob a book on June 1st"*, you can create an intermediate node representing the "giving" event and relate it to Alice, Bob, the book, and the date.

### 3. **Named Graphs**:
   - **Named graphs** allow you to group sets of RDF triples together and make statements about them as a whole (e.g., context, source, or provenance). In a sense, the named graph represents a **higher-level entity** that can be treated like an instance of a particular relationship or collection of statements.
   - While not directly creating instances of predicates, named graphs can provide a mechanism for **grouping statements** and treating the entire collection as an entity for further description, which aligns with a "predicate-instance" type of approach for contextual information.

### 4. **Singleton Property Pattern**:
   - The **[[singleton property|t.cs.semantic-web.singleton-property]] pattern** is another approach that deals with adding metadata to a statement by creating a **unique property** for each instance of a triple.
   - Instead of using a generic predicate, a **unique predicate** is created as a subclass or specialization of the original predicate, allowing you to make specific statements about that individual property.
   - This can be thought of as treating each occurrence of a predicate in a particular statement as a **distinct instance** of that predicate.

### 5. **Metamodeling with OWL**:
   - **OWL Full** allows **classes to be instances** of other classes, which might align with your approach of having predicates as classes and specific statements as instances.
   - In OWL, you can use a **metamodeling approach** to create **meta-classes** that represent predicates, and then create instances of these meta-classes to represent individual relationships or assertions. This offers a more flexible way to structure RDF graphs beyond simple triple patterns.

### Relevant Research and Considerations:
1. **Gruber, T. R. (1993). Toward Principles for the Design of Ontologies Used for Knowledge Sharing.** This paper laid the foundations for thinking about ontologies as modular representations of knowledge, which aligns with your approach of breaking down and treating predicates in a more instance-centric way.
2. **Singleton Property Papers**: Research papers on the singleton property pattern discuss creating unique properties for each instance of a relationship and can provide a foundation for exploring predicate-instance approaches.
3. **"Named Graphs, Provenance, and Trust" (Carroll et al., 

## i don't think traditional reification works because I want to represent the meaning, not the form, and so "subject" and "object" become arbitrary.

Given your goal to focus on **the meaning rather than the form** of statements, making the distinction between "subject" and "object" arbitrary, traditional reification indeed falls short, as it retains the structural components of RDF triples.

Instead of traditional reification, here are some alternative approaches that could better align with your "predicate-instance" idea:

### 1. **n-ary Relationships**
RDF is generally built around **binary relations** (subject-predicate-object), but to represent more complex relationships—where the subject-object distinction is arbitrary or you need more expressive power—you could use **n-ary relationships**. In an n-ary approach, instead of treating relationships as simple binary links, you represent the whole relationship itself as an entity. For example, a relationship could be expressed as:

```plaintext
_:relationship rdf:type ex:PredicateClass .
_:relationship ex:involves ex:Entity1 .
_:relationship ex:involves ex:Entity2 .
```
Here, the relationship is treated as an instance of a class (`ex:PredicateClass`), and both entities involved are simply linked without strictly defining a subject or object role. This way, the meaning of the relationship is emphasized over its structure.

### 2. **Higher-Order Logic and OWL Metamodeling**
Using **OWL metamodeling** techniques could be beneficial. In OWL, you can define classes for predicates and then have specific relationships as instances of those classes, thus abstracting away the rigid subject-object form. This is akin to treating relationships as **conceptual entities**, which can then be used to make further statements about the nature of these relationships.

For instance, if you want to represent a predicate as a class and have individual expressions of this predicate as instances:
- Define a class like `ex:Friendship`.
- Individual instances like `_:friendship1` or `_:friendship2` could represent specific expressions of that friendship, involving various entities (`ex:Person1` and `ex:Person2`), with different attributes or metadata about those instances.

### 3. **Graph Databases and Property Graph Models**
Traditional RDF might not provide enough flexibility for what you are trying to achieve, but some **graph databases** support **property graph models**, which allow edges (relationships) to have properties. This means you can attach more semantic meaning directly to relationships, treating them more as **first-class entities** that can be queried and manipulated with greater flexibility compared to RDF triples.

For example:
- **Neo4j** is a popular graph database that uses the **property graph model**, allowing relationships to carry properties. Instead of a subject-predicate-object structure, you could define edges with rich, descriptive properties, better capturing the intended semantics without the constraints of RDF's binary nature.

### 4. **RDF-Star and Embedded Triples**
**RDF-Star** is an extension of RDF that allows **embedded triples**, giving more flexibility in representing relationships. Instead of reifying statements explicitly, RDF-Star lets you make statements about other triples directly within the triple notation. This could be used to describe predicate instances in a way that captures more meaning while minimizing the subject-object distinction.

For example:
```plaintext
<<ex:Entity1 ex:predicate ex:Entity2>> rdf:type ex:PredicateInstance .
```
This lets you treat the triple itself as a **referential object** and make further statements about it, which could align more with your goal of capturing meaning.

### Summary
Your "predicate-instance" approach could be better realized using techniques that:
- Treat relationships as **entities** (n-ary relationships or metamodeling).
- Abstract away from the subject-object structure using **higher-order modeling**.
- Use graph models like **property graphs** or **RDF-Star** to add more semantic meaning directly to relationships.

These approaches provide more flexibility and can help represent meaning in a way that isn’t bound to the rigid structure of traditional RDF triples.

## property graph databases generally don't support resource-orientied properties on edges, i.e., only literals.

Given your need to support **resource-oriented properties on edges**, it's true that most property graph databases fall short, as they typically allow **only literal values** on relationship properties. However, there are some alternative modeling strategies and database technologies that might better meet your requirements:

### Alternative Approaches to Representing Rich Relationships:

1. **Hypergraph Models**:
   - **Hypergraphs** extend the concept of traditional graphs by allowing edges (often called "hyperedges") to connect multiple nodes, and these hyperedges themselves can be treated as first-class entities. This provides greater flexibility for representing complex relationships involving multiple resources.
   - Some graph databases, such as **HyperGraphDB**, are designed around the hypergraph concept, which might better accommodate resource-oriented properties for your use case.

2. **Multi-Edge Support in RDF Databases**:
   - Some RDF databases support **multi-edge** relationships and can add resource-oriented metadata to relationships through additional triples or through **reification** that uses custom classes to represent relationships. While reification might not be your preferred option, RDF databases like **Blazegraph** or **Stardog** offer richer modeling capabilities that go beyond basic property graphs.

3. **TinkerPop with Gremlin**:
   - **Apache TinkerPop** with **Gremlin** supports a more flexible way to define graph data. Although it still primarily focuses on property graphs, it allows complex traversal patterns that can effectively treat vertices (nodes) as holders of metadata for relationships. This can sometimes simulate richer semantics, though it won't inherently change the underlying restriction on edge properties.

4. **Graph-Relational Hybrid Approaches**:
   - A **hybrid approach** combining graph and relational databases might be useful. In this model, graph edges are modeled as separate entities in a relational table, allowing each edge to have resource-oriented properties. For example, **ArangoDB** supports both document and graph data models, potentially enabling more complex relationships to be represented.

5. **Custom Modeling in RDF-Star**:
   - **RDF-Star** (or **Triple-Star**) allows embedding RDF triples directly in other triples, giving more direct support for representing relationships that are richer than traditional edges. Using RDF-Star could be a way to model edges with resource-oriented properties without explicitly reifying the triple.
   - Example:
     ```
     <<ex:Node1 ex:relatesTo ex:Node2>> ex:hasProperty ex:Node3 .
     ```
     This effectively treats the embedded triple as a **referential object** to which properties can be attached.

### Limitations and Considerations:

- **Query Complexity**: Adding **resource-oriented metadata** to edges, particularly through approaches like RDF reification or RDF-Star, can introduce **query complexity**. You may need more sophisticated query handling to work with these enriched relationships efficiently.

- **Storage and Scalability**: Creating instances of relationships (predicate-instances) and modeling them as entities may lead to increased storage needs, depending on the granularity of your model and the scale of your data.

### Conclusion:
Given the constraints of property graph models (supporting only literal properties on edges), your approach would benefit from looking into **RDF-based models like RDF-Star** or **graph-relational hybrids**, which offer more flexibility in treating relationships as first-class entities. Alternatively, exploring **hypergraph** databases may offer a more natural fit for modeling resource-oriented properties on relationships. Each of these approaches offers a different balance of **flexibility**, **complexity**, and **scalability** depending on your specific needs for managing and querying relationships in your ontology.


## hypergraphdb is long dead, but maybe typedb could work. Any other hypergraph databases?

TypeDB (formerly **Grakn**) is indeed a promising candidate for what you're aiming to achieve, as it offers **type-based** modeling with **hyper-relational capabilities**, allowing relationships to be treated as entities that can have attributes. Besides TypeDB, there are a few other databases and tools that support **hypergraph** or **hyper-relational** modeling, which might fit your needs:

### Other Hypergraph and Hyper-Relational Databases:

1. **Neo4j with Relationship Nodes**:
   - Although **Neo4j** isn't a true hypergraph database, you can represent hypergraph-like relationships by creating **relationship nodes** explicitly. This approach makes relationships first-class citizens by modeling them as nodes, which can have their own relationships and properties, providing a similar effect to a hypergraph.

2. **TigerGraph**:
   - **TigerGraph** is a high-performance graph database that supports **multi-edge** relationships and **complex traversals**. While it primarily uses the property graph model, it allows extensive schema customization, which could be used to simulate hypergraph structures.

3. **ArangoDB**:
   - **ArangoDB** is a multi-model database that supports **graphs**, **documents**, and **key-value pairs**. By using its graph features, you can model hyperedges explicitly by creating collections of edges, each of which can be treated as a document with properties. This can provide the flexibility to add resource-oriented properties to edges.

4. **Neo4j Hypergraph Extension**:
   - There are some **extensions and plugins** for Neo4j that provide **hypergraph functionality**. These aren't official core features of Neo4j but can be helpful for exploring hypergraph-like modeling using Neo4j's underlying architecture.

5. **JanusGraph**:
   - **JanusGraph** is a distributed graph database that builds on top of existing technologies like **Apache Cassandra**, **HBase**, and **BerkeleyDB**. Although not a hypergraph database by default, it allows you to model rich relationships using property keys and multi-edge structures, which can approximate hypergraphs when implemented correctly.

6. **TerminusDB**:
   - **TerminusDB** is a knowledge graph and document-oriented database that supports **version control** and allows for **schema-rich, hyper-relational data modeling**. Its capability to handle complex relationships and its RDF-like approach might align well with your requirement for resource-oriented properties on edges.

7. **Knowledge Graph-based Alternatives**:
   - **Stardog** and **Blazegraph** are both RDF-based databases that can provide more flexibility in modeling complex relationships by representing them as first-class resources, with extensive support for OWL and advanced RDF features. These might be suitable if RDF extensions like **RDF-Star** or **n-ary modeling** could be adapted to your use case.

### Summary
While **HyperGraphDB** is no longer maintained, databases like **TypeDB**, **ArangoDB**, and extensions to **Neo4j** can help implement hypergraph-like functionality, where relationships are treated as fully modeled entities. If hypergraph support is crucial, **TypeDB** remains a strong candidate due to its emphasis on **hyper-relational modeling** and **semantic querying**.

Another option is to simulate hypergraph capabilities in databases that provide **rich schema modeling** for relationships, such as **ArangoDB** or **Neo4j** (using relationship nodes). If you lean toward more knowledge-graph-oriented approaches, **Stardog** or **Blazegraph** might also fit well, especially when paired with RDF's extended capabilities.

## Can you give an example of how tinkerpop can treat vertices (nodes) as holders of metadata for relationships. 

In **Apache TinkerPop**, you can model complex relationships by using **vertices (nodes) to represent metadata** about relationships, essentially making nodes act as relationship entities. This approach allows you to move beyond the typical edge representation, adding more context and richness to relationships.

Here's how you can do this using **TinkerPop's Gremlin traversal language**:

### Example Scenario: Representing Friendship Metadata

Suppose you want to represent a **friendship** between two people, and you want to capture additional metadata about this friendship—like when it started and who initiated it.

Instead of using a simple edge (e.g., `Person A -> "is_friend_of" -> Person B`), you can create a **friendship node** that acts as a holder of metadata for the relationship between two people.

#### Step-by-Step Modeling:

1. **Create Vertices for Persons**:
   ```gremlin
   // Create Person A and Person B
   g.addV('Person').property('name', 'Alice').as('a').
     addV('Person').property('name', 'Bob').as('b').
     iterate()
   ```

2. **Create a Friendship Vertex**:
   ```gremlin
   // Create a vertex to represent the friendship relationship with metadata
   g.addV('Friendship').property('startDate', '2023-01-15').property('initiator', 'Alice').as('f').
     iterate()
   ```

3. **Connect Persons to the Friendship Vertex**:
   ```gremlin
   // Create edges between the persons and the friendship vertex
   g.V().has('name', 'Alice').as('a').
     V().has('name', 'Bob').as('b').
     V().hasLabel('Friendship').as('f').
     addE('friend_with').from('a').to('f').
     addE('friend_with').from('b').to('f').
     iterate()
   ```

#### Explanation:

- **Friendship Vertex** (`f`): Represents the **relationship** itself and holds metadata about that relationship. In this case, the vertex has properties like `startDate` and `initiator`.
  
- **Edges (`friend_with`)**: Connect **Person A** and **Person B** to the **Friendship** vertex, creating a structure that indicates both people are part of the relationship while allowing you to treat the relationship itself as an entity with **attributes**.

#### Benefits:

- This allows you to **query the relationship** as an entity, add new metadata, or even link this relationship to other entities.
- For example, if the friendship evolves into a **business partnership**, you could create additional edges from the **Friendship vertex** to another **Business Partnership** vertex, reflecting real-world complexity without altering the original person nodes.

### Query Example:

To query the metadata of the friendship between **Alice** and **Bob**, you could write:

```gremlin
// Find the friendship between Alice and Bob and get its metadata
g.V().has('Person', 'name', 'Alice').out('friend_with').
  hasLabel('Friendship').as('f').
  in('friend_with').has('name', 'Bob').
  select('f').valueMap()
```

This query retrieves the **friendship vertex** that connects **Alice** and **Bob** and fetches all its properties, allowing you to easily access metadata like `startDate` or `initiator`.

### Summary:

Using **TinkerPop**, you can treat relationships as first-class entities by representing them with vertices. This approach allows you to add **rich metadata** to relationships, which is especially useful when modeling complex or evolving connections. The flexibility of using vertices to represent relationships, along with edges to link these vertices to their participants, enables richer semantic modeling compared to simple property graph edges.


## You said "in OWL, you can use a metamodeling approach to create meta-classes that represent predicates, and then create instances of these meta-classes to represent individual relationships or assertions." But are these really meta-classes? or just classes?

You're correct to question the terminology—whether these should be called **meta-classes** or just **classes** depends on the context in which they're used in OWL and the intent behind their creation.

### Clarification: Meta-Classes vs. Classes in OWL

In OWL, the term **meta-class** refers to a **class whose instances are themselves classes**. When modeling something at a higher level of abstraction, where you want classes to describe other classes (essentially creating a class of classes), you enter the territory of meta-modeling.

In the scenario where you want to represent **predicates** as **classes** and then instantiate these classes to represent specific relationships or assertions, you're not necessarily dealing with meta-classes. Rather, you're using **ordinary OWL classes** to represent a level of abstraction for predicates, which then have **instances** that represent the individual assertions of those predicates.

Here's a breakdown:

- **Classes Representing Predicates**: In your model, each predicate becomes a class. For instance, if you have a predicate like "knows," you would create a class called `Knows`.
- **Instances Representing Assertions**: You then create instances of this class (`Knows`) to represent specific assertions (e.g., "Alice knows Bob").

These **predicate classes** are not inherently meta-classes, as they are not intended to classify other classes. Instead, they are used to categorize **instances** that represent relationships. Therefore, they are better understood simply as **ordinary classes**, albeit with a specific role in representing relationships instead of more conventional entity types.

### Example in OWL:

1. **Define a Class for the Predicate**:
   ```turtle
   :Knows rdf:type owl:Class .
   ```

2. **Create Instances of the Predicate Class to Represent Assertions**:
   ```turtle
   :knowsAliceBob rdf:type :Knows ;
                  :subject :Alice ;
                  :object :Bob .
   ```

In this example:
- `:Knows` is a **class** representing the concept of the "knows" relationship.
- `:knowsAliceBob` is an **instance** of the class `:Knows`, representing the specific relationship between Alice and Bob.

Since `:Knows` is simply categorizing instances (`:knowsAliceBob`), it functions as a **standard OWL class**. A **meta-class**, by contrast, would be a class whose instances are themselves other OWL classes.

### Conclusion

In your "predicate-instance" approach, the **classes representing predicates** are better described as **ordinary classes** rather than meta-classes because they do not categorize other classes but instead **categorize instances** that represent specific relationships. This is an important distinction, as true meta-classes in OWL involve a different modeling purpose, typically to enable reasoning or organization of **classes themselves** as instances.

## You mentioned OWL Full could be helpful with its allowing**classes to be instances**. I think we agree that the predicates are not metaclasses. But do you still see any benefits to using OWL Full for the "predicate-instance" approach?

Yes, **OWL Full** can still provide significant benefits for your "predicate-instance" approach, even if we agree that the predicates themselves are not meta-classes. The key advantages of using **OWL Full** in this context include its ability to be **less restrictive** and its support for treating entities as both **classes and instances**. Here are some specific ways in which OWL Full could be beneficial:

### 1. **Class-Instance Flexibility**:
   - In **OWL Full**, an entity can simultaneously be a **class** and an **instance**. This is highly beneficial for the "predicate-instance" approach because:
     - **Predicates as Classes**: In your model, each predicate (like `ex:Knows`) can be treated as a **class** that groups all assertions of that predicate.
     - **Predicate Instances**: Specific relationships (`ex:knowsAliceBob`) can be instances of that class, representing the individual occurrences of these relationships.
   - OWL DL is more restrictive in this regard, as it requires a clear separation between classes, individuals, and properties, which could make it cumbersome for the flexible modeling you intend.

### 2. **Expressive Power**:
   - **OWL Full** provides greater **expressiveness** compared to **OWL DL**. It allows more complex constructs, such as treating properties themselves as instances, which can be beneficial when dealing with **predicate instances**.
   - You could, for example, express that a certain predicate class (`ex:Knows`) has additional metadata or relationships without the strict limitations imposed by OWL DL. This added expressiveness helps in capturing **richer semantics** about the predicates, their instances, and how they interrelate.

### 3. **Reification Alternative**:
   - Traditional RDF **reification** is quite cumbersome, requiring four triples per statement to reify a relationship. In **OWL Full**, the ability to treat predicates as classes and create instances for specific relationships can offer a more natural and **compact way** of representing relationship instances while still enabling you to attach rich metadata.
   - This avoids the reification structure that involves breaking a statement into multiple components (`rdf:subject`, `rdf:predicate`, `rdf:object`), which may not align well with your goal of focusing on the **meaning rather than the form** of statements.

### 4. **Property Characteristics**:
   - **OWL Full** allows properties to have characteristics such as **transitivity**, **symmetry**, and **inverse** relationships, even when these properties themselves are treated as classes or instances.
   - For example, you could define a class `ex:Collaboration` and indicate that instances of this class have an **inverse relationship** with another class, like `ex:Supervision`. This enables a more nuanced representation of relationships and helps encode the logic of how these relationships interact without the constraints of typical property definitions.

### 5. **Inference and Reasoning**:
   - With OWL Full, you can leverage **inference capabilities** to derive new knowledge from existing relationships, thanks to the more relaxed class-instance modeling. If a predicate is modeled as a class with specific instances, reasoning can be used to infer new relationships between instances or to validate the logical consistency of how predicates are applied.
   - For example, if `ex:Knows` is a class and instances of `ex:Knows` have properties that indicate a level of familiarity (`ex:acquaintance` or `ex:closeFriend`), an OWL Full reasoner can help infer additional facts about the relationships between entities based on the properties of those instances.

### 6. **Handling Complex Relationships**:
   - In your "predicate-instance" approach, predicates may themselves have **subclass relationships**, allowing for a hierarchy of predicates. In OWL Full, you can model a predicate class (`ex:Relationship`) with specific subclasses (`ex:Friendship`, `ex:BusinessPartnership`), and instantiate those subclasses with individual relationships (e.g., `ex:friendshipAliceBob`). This **hierarchical modeling** provides a richer framework for categorizing and reasoning about relationships compared to property graphs or RDF alone.

### Summary:
- **OWL Full** allows you to use **classes as instances**, providing the necessary flexibility for treating predicates as classes and individual relationships as instances.
- It enables **richer expressiveness**, which helps model complex relationships and their interactions without the limitations of **OWL DL** or standard **RDF**.
- It supports using **inference and reasoning** to derive additional information, providing added value over simple property graphs.
- **Hierarchical modeling** of predicates and their instances can be effectively implemented, supporting nuanced ontological structures.

While **OWL Full** comes with trade-offs like reduced computational efficiency for reasoning compared to **OWL DL**, it offers the flexibility and expressiveness required for implementing a **predicate-instance** approach effectively, especially when dealing with complex relationships and the need to attach additional semantics to these relationships.

## I don't think #1 makes sense. Expressivity could be useful. For #3, I don't think my approach is much more compact, it still requires one statement to set up the predicate, and  would need a statement each for subject and object. So maybe saves a statement. For #4, can you really express transitivity, symmetry, etc. in the traditional way between classes? I mean, I guess OWL full allows you too, but reasoners probably wouldn't support that. #5 Inferencing, I think it mostly requires OWL DL. #6 I totally agree with.


Thanks for clarifying your thoughts. Based on your feedback, let's refine the evaluation of OWL Full for the "predicate-instance" approach:

### Revised Evaluation:

1. **Class-Instance Flexibility** (Initial Point Removed)
   - Since you are not treating predicates as meta-classes, this point about flexibility was unnecessary. Instead, we can focus on **expressivity** as the key benefit, which you highlighted.

2. **Expressive Power**
   - **OWL Full** allows richer and more complex modeling than **OWL DL**, which could be useful for representing nuanced relationships and treating predicates as first-class entities. This flexibility can help in situations where relationships evolve or have multiple layers of meaning. This expressivity could make OWL Full a suitable choice for implementing a "predicate-instance" approach in a more **semantic and nuanced manner**, though it might come at the cost of **reduced computational efficiency** for inferencing.

3. **Reification Alternative** (Modified)
   - You’re correct that your approach might not be much more compact than traditional **RDF reification**—you still need a statement to set up the predicate and additional statements for each of the subject and object. While it could save one statement compared to standard reification, this is not necessarily the main advantage. Instead, the benefit might lie in the more **natural conceptualization** of predicates as entities and their instances, making the data model more intuitive for representing complex relationships.

4. **Property Characteristics (Transitivity, Symmetry, etc.)** (Clarified)
   - You raised a valid point about the feasibility of representing properties like **transitivity** and **symmetry** between classes. While **OWL Full** allows this level of expressiveness, it's true that most **reasoners** do not support inferencing on such characteristics between classes in OWL Full. Therefore, while it’s possible to model transitivity and symmetry at the class level in OWL Full, practical **reasoning support** might be limited. If automated inferencing is a requirement, then **OWL DL** is generally more suitable, albeit more restrictive in its expressiveness.

5. **Inference and Reasoning** (Refined)
   - **Inferencing** in OWL Full is theoretically possible, but as you mentioned, it is often **unsupported by practical reasoners**. Most reasoners are built with **OWL DL** in mind, given the tractable nature of reasoning in this subset of OWL. If **automated reasoning** is a core requirement of your model, OWL DL may be necessary, even though it would impose limitations on modeling flexibility compared to OWL Full.

6. **Hierarchical Modeling of Relationships (Confirmed)**
   - You agree that **OWL Full** provides an advantage for **hierarchical modeling** of predicates. In your "predicate-instance" approach, representing **predicates as classes** and building **subclass relationships** (e.g., different types of relationships like `Friendship`, `Collaboration`) provides a powerful framework for reasoning about different levels of abstraction. OWL Full allows you to freely model these classes and create instances for specific assertions, aligning with your intention to treat predicates as rich conceptual entities.

### Summary of Changes:
- **Expressivity** in OWL Full remains a key potential benefit for allowing nuanced and flexible representations of relationships, despite the limitations in reasoning support.
- The compactness benefit over **RDF reification** is minimal; instead, the benefit lies more in the **conceptual clarity** of representing predicates as entities.
- Representing **property characteristics like transitivity and symmetry** between classes is allowed in OWL Full, but practical support from reasoners is typically lacking.
- For **inference** needs, **OWL DL** would be the more appropriate choice, as most reasoners support it effectively, though at the cost of reduced modeling flexibility.

OWL Full provides a powerful and expressive framework, but practical limitations in terms of **reasoner support** need to be carefully considered based on your specific requirements for reasoning and modeling flexibility.


## Maybe there's a better name than "predicate-instance approach". Like "predicate-first" or "predicentric" or ???

Here are some alternative names that might better capture your approach to ontologies where predicates are central, represented as classes, and relationships as instances:

1. **Predicate-Centric Modeling**: Emphasizes that **predicates** are at the core of your model, highlighting their central role. This name suggests that your model revolves around predicates as primary entities.

2. **Predicate-First Approach**: Similar to "predicate-centric," this highlights that **predicates** are prioritized first, making it clear that the model starts with defining and focusing on predicates.

3. **Predicentric Ontology**: A creative play on "centric" and "predicate," this term sounds cohesive and implies that predicates are the fundamental unit of organization.

4. **Relational Entity Ontology**: Since your approach makes each predicate a **distinct entity** (or class) with instances, this name emphasizes that **relationships themselves are entities**.

5. **Relator-Based Approach**: Though you've noted that "relator-based" might not fully capture your concept, the term could still be relevant, especially if the **relationships are central** to your model and the focus is on their instantiation as real entities.

6. **Predicate Reification**: If you want to emphasize that your approach is related to giving **substance** to predicates, even if it's not traditional reification, this could be a fitting term.

7. **Hyper-Relational Modeling**: Suggests a richer modeling of relationships that goes beyond simple predicates, treating them as **full-fledged entities**.

8. **Predicate Realization**: Suggests the act of making predicates **explicit and concrete** by realizing them as distinct classes and instances.

Each of these names provides a different nuance, focusing on either the centrality of predicates, their entity-like nature, or the unique modeling structure you're using. "Predicate-Centric" or "Predicate-First" might be especially clear and direct for your purpose.