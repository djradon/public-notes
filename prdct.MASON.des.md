---
id: hzpq2wetfen37fjcav6a2vw
title: MASON DES
desc: 'discrete event simulation extension for MASON'
updated: 1712678192158
created: 1712677554992
---

## Summary

MASON’s DES classes may be roughly divided into four categories: Resources, Processes, Composed Pro-
cesses, and Visualization Tools. 

### Resources 

Money, love, gasoline, palettes of goods, cargo containers, water, and people waiting in line are all resources. They’re things handed off from process to process to make a DES simulation hum. The abstract superclass is **Resource**. A simple Resource is **Entity**, an atomic object like a skeeball ticket or a video game token. Entities can also serve as containers for collections of Resources, much like a cargo container, a truck of goods, or a palette of microwaves. these are called Eomposite Entities. **CountableResources** are Resources which can have have integer amounts greater than one (they’re not Entities) and cannot be infinitely subdivided. For example, you can have 1000 medicine pills, or 200 eggs, but you can’t have half an egg. Money is a CountableResource which prints nicely (like $ 4.32). UncountableResources are Resources which are infinitely subdivisible, like water or love or gasoline or time. You can make as many Resources as you like of various types, as members of these general classes. 

### Processes 

- Processes perform actions in response to events. In most cases, this action involves Processes handing off Resources to other Processes

A Process is an object which hands resources to another process or receives the same. There are three major abstract kinds of Processes. A **Provider** provides resources. A **Receiver** receives resources from a Provider. A **Middleman** is both a Provider and a Receiver: it receives resources from Providers, and then provides them to downstream Receivers. MASON’s DES system is mostly a “push” system: providers generally offer resources to receivers (who may choose to accept or reject the offer). However in many cases it also has an optional “pull”: receivers can ask providers offer resources to them (or in some cases, to offer resources to other receivers), and providers may respond to these entreaties or ignore them. 

Consider a classic MM1 Queue: people arrive at a bank, then waiting in line at a bank teller. Here people are represented as Entities. They are generated by a **Source**, which produces the people entering the bank. Sources can produce resources (people) at random, via a schedule, and so on. The Source then hands its produced people to a **Queue**, which represents the line they have to wait in. A Queue can also be thought of as a warehouse of items waiting to be processed. The Queue then attempts to feed people through a **Lock**, which only allows people to pass if it can allocated a different Resource (let’s call it a Teller) from a **Pool** of Tellers. In our case there’s only a single Teller, so if the Pool doesn’t have one available for the Lock, the Lock refuses to let the next person move forward. when a Lock can allocate a Teller and let a person move forward, the person is handed off to a **SimpleDelay**, which holds the person for a fixed amount of time, representing the time the Teller needs to service the person. When the SimpleDelay lets go of the person, it is handed off to an **Unlock**, which places the Teller resource back in the Queue and informs the Lock that a Teller is available again. The person is then finally handed to a **Sink**, which is basically a black hole in which Resources disappear forever, and represents the end of the line for people in the model. There are actually three kinds of Delays available. A SimpleDelay delays resources for a fixed amount of time. A **Delay** delays them for a varying amounts of time (but is more costly). A **BoundedDelay** delays them for varying amounts of time as long as those times are integer values less than some number N (it’s cheaper than a Delay). Some more processes. An **If** receives incoming Resources and sends them to one or another of different downstream receivers based on some decision you specify. A Composer takes multiple different resources and packs them together into a **Composite Entity**. A **Decomposer** does the opposite. An **Extractor** is a kind of Source which produces resources by requesting them from another Provider. A **Transformer** is like a currency converter: it accepts Resources and produces (converts them into) different kinds of Resources. A **Probe** lets Resources pass through it, but records the amount and rate for statistical purposes. It can be used in combination with a **Lead**: together they can measure the amount and rate of Resource passing through a subgraph of processes. These Processes are all designed to be subclassed and customized to your heart’s content. 

### Composed Processes 

MASON provides two ways to compose Processes. First, there are **Macros**. A Macro wraps a subgraph of Processes in a neat little package and lets you repeat this subgraph over and over cleanly. It’s a useful abstraction tool. A **Service** is a commonly used Macro. 

Second, there are **Multis**. Normally Processes deal with one incoming type of Resource and one outgoing type of Resource, often the same. But a Multi lets you have many incoming and outgoing types of Resources from different sources and destinations. You might use a Multi to model a bicycle factory: it takes steel, and bike components, and energy, and produces bicycles and trash. Muiltis are meant to be customized: they don’t do anything interesting on their own. 


### Visualization Facilities 

All of the DES system’s processes, and their interconnections may be visualized and inspected using standard MASON facilities. To make this easy, the processes serve as their own Simple Portrayals, and DES system provides a variety of tools to display them and customize them.

